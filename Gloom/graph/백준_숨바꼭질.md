# 문제 구성 📖
> 코딩테스트 사이트 : 백준  
> 난이도 : 실버2     
> 풀이 날짜 : 2022.06.18 
> 사용한 풀이 방법 : DFS

## 문제링크
https://www.acmicpc.net/problem/1697

## 풀이법
> 수빈이가 동생위치까지 이동하는 `최단 이동횟수`를 구하는 문제이다. 
- 일단 수빈이가 이동할 수 있는 방법은 3가지이다.
- 그리고 또 이동할 수 있는 방법은 또 다시 3가지이다.
  - DFS로 예상 시간 복잡도 3^n 이 나올것 같지만,
  - 우선순위를 잘 두면서 하면 가능할거 같아 보인다.

### 수빈이랑 동생의 위치 상황은 3가지이다.
- 수빈이 위치 > 동생의 위치
- 수빈이 위치 < 동생의 위치
- 수빈이 위치 == 동생의 위치

### 그럼 각 상황에서 취할 수 있는 행동은 다음과 같다.
- 수빈이 위치 > 동생의 위치 :  `x-1`   => 시간 복잡도 N 이다.
- 수빈이 위치 < 동생의 위치 :  `2x` , `x+1` => 시간 복잡도 2^N이다.
- 수빈이 위치 == 동생의 위치 :  리턴

### 주의사항
 - 여기서 함정이 있는데,
 - 예를 들어 
   - 수빈이 위치 > 동생의 위치 `x-1`을 `4번`해야되는데,
   - 앞에서 `2x`가 있었을 경우 앞에서 `x-1`을 `2번`만 해줘도 된다.

### 해결방안 
 - `2x`를 한 횟수를 별도로 세고, 횟수에 맞춰..
 - `수빈이 위치 - 동생의 위치` = 나온 값(`diff`)을  `2^n`으로 나눈 몫 만큼 더한다.

---


## 알고리즘 설계
- DFS를 설계한다. 
- 수빈이의 위치가 동생의 위치보다 클 경우(`수빈 > 동생`) 함수로 구현해준다. 
- 이동횟수가 가장 작은 숫자를 출력한다.
 
### 주어지는 조건
 - N(수빈의 위치) (최대 10만)
 - K(동생의 위치) (최대 10만)


```java
public class HideAndSeek {

    static int minValue = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken()); //수빈 위치
        int K = Integer.parseInt(st.nextToken()); //동생 위치

        int count = 0;
        int multiTwoCount = 0;

        DFS(K,N,0,0);

        System.out.println(minValue);
        br.close();
    }

    public static void DFS(int K, int curLocation, int count, int multiTwoCount) {
        if(count > minValue){ // 시간초과가 떠서 추가한 코드,  쓸데없는 계산 버림
            return;
        }
        if (curLocation >= K) {
            int addCount = moveCalculate(multiTwoCount, curLocation - K);
            count += addCount;
            if (minValue > count) {
                minValue = count;
            }
            return;
        }
        //if (curLocation < K)
        DFS(K, curLocation * 2, count + 1, multiTwoCount + 1);
        DFS(K, curLocation + 1, count + 1, multiTwoCount);


    }

    public static int moveCalculate(int multiTwoCount, int diff) {
        int div = (int) Math.pow(2, multiTwoCount);
        int move = 0;
        while (diff > 1) {
            if ((diff / div) > 0) move += (diff / div);
            diff = diff % div;
            div /= 2;
        }
        if (diff == 1) move++;

        return move;
    }

}
```

- 하지만 그 결과는 아래와 같다.
<img src="https://user-images.githubusercontent.com/104331549/174432966-42bdd8fb-891b-4085-b236-11e3744bd7ce.png">

- DFS로는 메모리 초과가 나온다. 

