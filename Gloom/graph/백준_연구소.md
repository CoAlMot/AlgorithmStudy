# ë¬¸ì œ êµ¬ì„± ğŸ“–
> ì½”ë”©í…ŒìŠ¤íŠ¸ ì‚¬ì´íŠ¸ : ë°±ì¤€  
> ë‚œì´ë„ : ê³¨ë“œ5     
> í’€ì´ ë‚ ì§œ : 2022.07.24  
> ì‚¬ìš©í•œ í’€ì´ ë°©ë²• : ì™„ì „íƒìƒ‰, ë°±íŠ¸ë˜í‚¹, BFS

## ë¬¸ì œë§í¬
https://www.acmicpc.net/problem/14502

## í’€ì´ë²•
> ì—°êµ¬ì†Œì—ì„œ ë°”ì´ëŸ¬ìŠ¤ê°€ ìœ ì¶œë˜ëŠ”ë°, ë²½3ê°œë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì „ì˜ì—­ í¬ê¸°ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. 

- ì…ë ¥ê°’ ì²«ë²ˆì§¸ ì¡°ê±´
  - ì²«ì§¸ ì¤„ì— ì§€ë„ì˜ ì„¸ë¡œ í¬ê¸° Nê³¼ ê°€ë¡œ í¬ê¸° Mì´ ì£¼ì–´ì§„ë‹¤. (3 â‰¤ N, M â‰¤ 8)
  - ì´ê±¸ ë³´ê³ , ê·¸ë˜í”„ ìì²´ê°€ í¬ì§ˆ ì•Šì•„, **ì™„ì „íƒìƒ‰**ìœ¼ë¡œ í’€ë©´ ì¢‹ê² ë‹¤ ìƒê°í–ˆê³ 

- 0ì€ ë¹ˆ ì¹¸, 1ì€ ë²½, 2ëŠ” ë°”ì´ëŸ¬ìŠ¤ê°€ ìˆëŠ” ìœ„ì¹˜ì´ë‹¤.
  - 2ì˜ ê°œìˆ˜ëŠ” 2ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ê³ , 10ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìì—°ìˆ˜ì´ë‹¤.
  - 2ê°œì˜ ê°¯ìˆ˜ë¥¼ ë¨¼ì € íŒŒì•…í•  ìˆ˜ ìˆì„ê²ƒê°™ì•˜ë‹¤. 
  - 2ì˜ ê°¯ìˆ˜ê°€ 4ê°œì´ìƒì´ ë˜ì–´ ë²„ë¦¬ë©´, ë²½ìœ¼ë¡œ ê°ì‹¸ì§ˆ ëª»í•¨ìœ¼ë¡œ, í˜„ì¬ ë‚¨ì•„ìˆëŠ” ì˜ì—­ì„ ìµœëŒ€í•œ ë„“ì´ëŠ” ìª½ìœ¼ë¡œ 
  - 2ì˜ ê°¯ìˆ˜ê°€ 3ê°œ ì´í•˜ë©´, ì–´ë–»ê²Œë“  ë²½ìœ¼ë¡œ ê°ì‹¸ëŠ” ìª½ìœ¼ë¡œ í•´ê²°í•´ì•¼ë˜ì§€ ì•Šë‚˜ ì‹¶ë‹¤.


- ì•ˆì „ì˜ì—­ì˜ ìµœëŒ€ê°’ êµ¬í•˜ëŠ” ë°©ì‹ì€, ë²½ 3ê°œë¥¼ ì„¸ì›Œë‘ê³ , ë°”ì´ëŸ¬ìŠ¤ì¸ 2ë¥¼ í™•ì‚° ì‹œí‚¨ë‹¤ìŒ, ë‚¨ì€ 0ì˜ ê°¯ìˆ˜ë¥¼ ì„¸ëŠ” ë°©ì•ˆìª½ìœ¼ë¡œ ìƒê°í•œë‹¤. 

> ê·¸ë¦¬ê³  ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€, ë²½ì„ 3ê°œë¥¼ ë†“ì„ë•Œ, ì¼ì§ì„ ìœ¼ë¡œ ë†“ëŠ”ê²Œ ì•„ë‹Œ, ë¬´ì¡°ê±´ ëŒ€ê°ì„  ìœ¼ë¡œë„£ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤.

1ë¥¼ ë†“ëŠ” ì¡°ê±´ì„ ë§Œë“ ë‹¤. 


ì™„ì „ íƒìƒ‰ìœ¼ë¡œ í’€ì–´ë³¼ë ¤ê³  í–ˆì§€ë§Œ íƒë„ ì—†ì—ˆë‹¤.

## 1ì°¨ ì‹œë„
 - êµ¬í˜„ íë¦„ì€ ì•„ë˜ì™€ ê°™ë‹¤.
   1. ë¨¼ì € ë²½3ê°œê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ êµ¬í•œë‹¤. 
   2. ê°ê° ê²½ìš°ì—ìˆ˜ ê°€ êµ¬í•´ì§ˆë•Œ ë§ˆë‹¤, ë°”ì´ëŸ¬ìŠ¤ë¥¼ í™•ì‚° ì‹œí‚¨ë‹¤. 
   3. ë²½ë„ ì„¸ì›Œì§€ê³ , ë°”ì´ëŸ¬ìŠ¤ë„ í™•ì‚°ëœ ìƒíƒœì—ì„œ ì•ˆì „êµ¬ì—­ì˜ ê°¯ìˆ˜ë¥¼ ì„¼ë‹¤. 
   4. ìµœëŒ“ê°’ì´ë‘ ë¹„êµí•˜ì—¬, í¬ë©´ ëŒ€ì²´í•œë‹¤. 
   5. ìµœëŒ“ê°’ ë¦¬í„´


- í•˜ì§€ë§Œ, ì˜¤ë²„í”Œë¡œìš° ìŠ¤íƒì´ ë‚˜ë²„ë¦°ë‹¤.
```java
package Beakjoon.gold;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class ResearchVirus {
    static int[] dx = {1, 0, -1, 0};
    static int[] dy = {0, 1, 0, -1};
    static int N = 0;
    static int M = 0;
    static int[][] matrix;
    static int max = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken()); // í–‰
        M = Integer.parseInt(st.nextToken()); // ë ¬

        matrix = new int[N][M];
        int[][] testMatrix;


        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                matrix[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        
        boolean[][] visited = new boolean[N][M];

        // ë°°ì—´ ë³µì‚¬
        testMatrix = copyArray();

        DFS(testMatrix, 0, 0,0);
        
        System.out.println("max = " + max);

        br.close();
    }

    private static void DFS(int[][] testMatrix,int depth, int x, int y) {
        if(depth == 3){
            // ë°”ì´ëŸ¬ìŠ¤ í¼íŠ¸ë¦¬ê¸°
            virusSpreading(testMatrix);

            // ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ ì„¸ê¸°
            int safeArea = countSafeArea(testMatrix);
            if(max < safeArea) {
                max = safeArea;
                System.out.println("safeArea = " + safeArea);
            }
            return;
        }
        for (int i = x; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if(i==x)
                    if(j ==M-1) i++;
                    else j= y +1;

                if(testMatrix[i][j] == 0){
                    testMatrix[i][j] = 1;
                    DFS(testMatrix, depth+1, i,j);
                    testMatrix[i][j] = 0;
                    DFS(testMatrix, depth, i, j);
                }
            }
        }
    }


    private static int[][] copyArray() {
        int[][] newArr = new int[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                newArr[i][j] = matrix[i][j];
            }
        }
        return newArr;
    }


    public static void virusSpreading(int[][] checkMatrix) {
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (checkMatrix[i][j] == 2 && !visited[i][j]) {
                    queue.add(new int[]{i, j});
                    virusSpread(checkMatrix, queue, visited);
                }
            }
        }

    }

    private static void virusSpread(int[][] checkMatrix, Queue<int[]> queue, boolean[][] visited) {
        int x;
        int y;
        while (!queue.isEmpty()) {
            x = queue.peek()[0];
            y = queue.peek()[1];
            queue.poll();
            visited[x][y] = true;
            for (int i = 0; i < 4; i++) {
                int nextX = x + dx[i];
                int nextY = y + dy[i];

                if (nextX < 0 || nextX > N - 1 || nextY < 0 || nextY > M - 1)
                    continue;
                if (checkMatrix[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                    checkMatrix[nextX][nextY] = 2;
                    queue.add(new int[]{nextX, nextY});
                }
            }
        }
    }

    public static int countSafeArea(int[][] checkMatrix) {
        int safeCount = 0;
        boolean[][] visited = new boolean[N][M];
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (checkMatrix[i][j] == 0 && !visited[i][j]) {
                    queue.add(new int[]{i, j});
                    safeCount += getSafeCount(checkMatrix, safeCount, visited, queue);
                }
            }
        }
        return safeCount;
    }

    private static int getSafeCount(int[][] checkMatrix, int safeCount, boolean[][] visited, Queue<int[]> queue) {
        safeCount = 1;
        int x;
        int y;
        while (!queue.isEmpty()) {
            x = queue.peek()[0];
            y = queue.peek()[1];
            queue.poll();
            visited[x][y] = true;
            for (int i = 0; i < 4; i++) {
                int nextX = x + dx[i];
                int nextY = y + dy[i];

                if (nextX < 0 || nextX > N - 1 || nextY < 0 || nextY > M - 1)
                    continue;
                if (checkMatrix[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                    safeCount++;
                    queue.add(new int[]{nextX, nextY});
                }
            }
        }
        return safeCount;
    }


}
```

 - êµ¬í˜„ì´ ìµìˆ™ì¹˜ì•Šì•„ì„œ ì—¬ëŸ¬êµ°ë°ì—ì„œ ì—ëŸ¬ê°€ ë‚¬ë‹¤. 
 - ê¸°ì´ˆë¶€í„° ì°¨ê·¼ì°¨ê·¼ ìŒ“ì•„ë†”ì•¼ê² ë‹¤. 
 - ì½”ë“œë¥¼ í•˜ë‚˜ì”© ëœ¯ì–´ ë³´ì

### 1. ë¨¼ì € ë²½3ê°œê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ êµ¬í•œë‹¤. 
 - ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ìœ¼ë¡œëŠ” 
   - DFSì˜ ê²½ìš° ë°±íŠ¸ë¦¬í‚¹ì´ë‚˜, ì¬ê·€ë¡œ êµ¬í˜„í•˜ë©´ ë˜ê³ , 
   - BFSì˜ ê²½ìš° Queueë¥¼ ì‚¬ìš©í•˜ë©´ ë˜ëŠ”ë°
   - ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•´ì•¼í•¨ìœ¼ë¡œ, **DFSê°€ ë” ì í•©í•œ ê²ƒ ê°™ë‹¤.**

```java
private static void DFS(int depth) {
    if(depth == 3){
        // ë°”ì´ëŸ¬ìŠ¤ í¼íŠ¸ë¦¬ê¸°
        // ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ ì„¸ê¸°
        return;
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if(matrix[i][j] == 0){
                matrix[i][j] = 1;
                DFS(depth+1);
                matrix[i][j] = 0;
            }
        }
    }
}
```
 - ìœ„ ì½”ë“œëŠ” ë¦¬í™í† ë§ ê³¼ì •ì„ í†µí•´, `matrix`ë³€ìˆ˜ë¥¼ ì „ì—­ë³€ìˆ˜ë¡œ ë§Œë“¤ì–´ ë°–ìœ¼ë¡œ ë¹¼ë‚¸ê²½ìš°ì´ë‹¤.

<br></br>
<br></br>

### 2.ê°ê° ê²½ìš°ì—ìˆ˜ ê°€ êµ¬í•´ì§ˆë•Œ ë§ˆë‹¤, ë°”ì´ëŸ¬ìŠ¤ë¥¼ í™•ì‚° ì‹œí‚¨ë‹¤. 
 - ë°”ì´ëŸ¬ìŠ¤ëŠ” ìˆ«ì 2ë¡œ, ìƒí•˜ì¢Œìš°ë¡œ í™•ì‚° ì‹œí‚¬ìˆ˜ ìˆë‹¤. 
 - í™•ì‚° ë°©ë²•ì´ BFSì™€ ìœ ì‚¬í•¨ìœ¼ë¡œ BFSë¡œ ì²˜ë¦¬í•´ì£¼ì—ˆë‹¤. 
   - ì—¬ê¸°ì„œ 2ì°¨ì› ë°°ì—´ì„ ì‚¬ìš©í•´ì•¼ í•¨ìœ¼ë¡œ, ë³µì‚¬í•´ì„œ ì‚¬ìš©í–ˆë‹¤.

<br></br>

 - ë°”ì´ëŸ¬ìŠ¤ í™•ì‚°ì „ í•„ìš”í•œ ê°’ ì„¸íŒ…ë©”ì†Œë“œ
```java
 public static int[][] virusSpreading() {
    int[][] cloneMatrix = copyArray(); // ë³µì‚¬ 
    Queue<int[]> queue = new LinkedList<>();
    boolean[][] visited = new boolean[N][M];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (cloneMatrix[i][j] == 2 && !visited[i][j]) {
                queue.add(new int[]{i, j});
                virusSpread(cloneMatrix, queue, visited);
            }
        }
    }

    return cloneMatrix;
}
```

 - í˜„ì¬ ì—°êµ¬ì†Œ ë§µ ë³µì‚¬í•˜ëŠ” ë©”ì†Œë“œ
```java
private static int[][] copyArray() {
    int[][] newArr = new int[N][M];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            newArr[i][j] = matrix[i][j];
        }
    }
    return newArr;
}
```
 - 2ê°€ í™•ì‚°ê°€ëŠ¥í•œ ê³³ë§ˆë‹¤, 2ë¡œ ê°€ë“ ì±„ì›Œì£¼ëŠ” ë©”ì†Œë“œ(BFSì‚¬ìš©)
```java
private static void virusSpread(int[][] cloneMatrix, Queue<int[]> queue, boolean[][] visited) {
    int x;
    int y;
    while (!queue.isEmpty()) {
        x = queue.peek()[0];
        y = queue.peek()[1];
        queue.poll();
        visited[x][y] = true;
        for (int i = 0; i < 4; i++) {
            int nextX = x + dx[i];
            int nextY = y + dy[i];

            if (nextX < 0 || nextX > N - 1 || nextY < 0 || nextY > M - 1)
                continue;
            if (cloneMatrix[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                cloneMatrix[nextX][nextY] = 2;
                queue.add(new int[]{nextX, nextY});
            }
        }
    }
}
```

<br></br>
<br></br>


### 3.ë²½ë„ ì„¸ì›Œì§€ê³ , ë°”ì´ëŸ¬ìŠ¤ë„ í™•ì‚°ëœ ìƒíƒœì—ì„œ ì•ˆì „êµ¬ì—­ì˜ ê°¯ìˆ˜ë¥¼ ì„¼ë‹¤.
  - ë§Œë“¤ì–´ì§„ ì—°êµ¬ì†Œ ë§µì˜ 0ì˜ ê°¯ìˆ˜ë§Œ ì„¸ë©´ ë˜ë‹ˆê¹Œ, ì™„ì „íƒìƒ‰ìœ¼ë¡œ ì°¾ì•„ì¤€ë‹¤.
```java
public static int countSafeArea(int[][] cloneMatrix) {
    int safeCount = 0;
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
          if (cloneMatrix[i][j] == 0) {
            safeCount++;
          }
        }
      }
    return safeCount;
}
```

### 4. ìµœëŒ“ê°’ì´ë‘ ë¹„êµì½”ë“œë¥¼ ë„£ì–´ì¤€ë‹¤.
 - ë²½ì´ ì„¸ê°œê°€ ì„¤ì¹˜ë˜ì—ˆì„ë•Œ, ë°”ì´ëŸ¬ìŠ¤í™•ì‚°ì‹œì¼œì£¼ëŠ” ë©”ì†Œë“œì™€ ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ì„¸ëŠ” ë©”ì†Œë“œë¥¼ ë„£ì–´ì¤€ë‹¤.
 - ê·¸ë¦¬ê³  ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ê°€ ìµœëŒ€ê°’ì´ì–´ì•¼í•˜ë‹ˆ, ìµœëŒ€ê°’ êµ¬í•˜ëŠ” ì½”ë“œë„ ë„£ì–´ ì¤€ë‹¤.
   -  `max`ë³€ìˆ˜ëŠ” ì „ì—­ë³€ìˆ˜ë¡œ ì²˜ë¦¬
```java
private static void DFS(int depth) {
    if(depth == 3){
        // ë°”ì´ëŸ¬ìŠ¤ í¼íŠ¸ë¦¬ê¸°
        int[][] cloneMatrix = virusSpreading();

        // ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ ì„¸ê¸°
        int safeArea = countSafeArea(cloneMatrix);
        if(max < safeArea) {  // ìµœëŒ€ê°’ êµ¬í•˜ëŠ” ì½”ë“œ
            max = safeArea;
        }
        return;
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if(matrix[i][j] == 0){
                matrix[i][j] = 1;
                DFS(depth+1);
                matrix[i][j] = 0;
            }
        }
    }
}
```


### 5. ìµœì¢… ì½”ë“œ 

```java
package Beakjoon.gold;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class ResearchVirus {
  static int[] dx = {1, 0, -1, 0};
  static int[] dy = {0, 1, 0, -1};
  static int N = 0;
  static int M = 0;
  static int[][] matrix;
  static int max = 0;

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st = new StringTokenizer(br.readLine());

    N = Integer.parseInt(st.nextToken()); // í–‰
    M = Integer.parseInt(st.nextToken()); // ë ¬

    matrix = new int[N][M];

    for (int i = 0; i < N; i++) {
      st = new StringTokenizer(br.readLine());
      for (int j = 0; j < M; j++) {
        matrix[i][j] = Integer.parseInt(st.nextToken());
      }
    }

    DFS(0);
    System.out.println("max = " + max);  // maxê°’ ì¶œë ¥
    br.close();
  }

  private static void DFS(int depth) {
    if (depth == 3) {
      // ë°”ì´ëŸ¬ìŠ¤ í¼íŠ¸ë¦¬ê¸°
      int[][] cloneMatrix = virusSpreading();

      // ì•ˆì „êµ¬ì—­ ê°¯ìˆ˜ ì„¸ê¸°
      int safeArea = countSafeArea(cloneMatrix);
      if (max < safeArea) {
        max = safeArea;
      }
      return;
    }
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        if (matrix[i][j] == 0) {
          matrix[i][j] = 1;
          DFS(depth + 1);
          matrix[i][j] = 0;
        }
      }
    }
  }


  public static int[][] virusSpreading() {
    int[][] cloneMatrix = copyArray();
    Queue<int[]> queue = new LinkedList<>();
    boolean[][] visited = new boolean[N][M];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        if (cloneMatrix[i][j] == 2 && !visited[i][j]) {
          queue.add(new int[]{i, j});
          virusSpread(cloneMatrix, queue, visited);
        }
      }
    }

    return cloneMatrix;
  }

  private static int[][] copyArray() {
    int[][] newArr = new int[N][M];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        newArr[i][j] = matrix[i][j];
      }
    }
    return newArr;
  }

  private static void virusSpread(int[][] cloneMatrix, Queue<int[]> queue, boolean[][] visited) {
    int x;
    int y;
    while (!queue.isEmpty()) {
      x = queue.peek()[0];
      y = queue.peek()[1];
      queue.poll();
      visited[x][y] = true;
      for (int i = 0; i < 4; i++) {
        int nextX = x + dx[i];
        int nextY = y + dy[i];

        if (nextX < 0 || nextX > N - 1 || nextY < 0 || nextY > M - 1)
          continue;
        if (cloneMatrix[nextX][nextY] == 0 && !visited[nextX][nextY]) {
          cloneMatrix[nextX][nextY] = 2;
          queue.add(new int[]{nextX, nextY});
        }
      }
    }
  }

  public static int countSafeArea(int[][] cloneMatrix) {
    int safeCount = 0;
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < M; j++) {
        if (cloneMatrix[i][j] == 0) {
          safeCount++;
        }
      }
    }
    return safeCount;
  }

}
```

### ëŠë‚€ì  
- ë‚œì´ë„ê°€ ìˆì–´, íš¨ìœ¨ì ì¸ ì½”ë“œë³´ë‹¤ëŠ” í†µê³¼í•˜ëŠ” ì½”ë“œë¥¼ ê°€ë…ì„±ìˆê²Œ ì§œë ¤ê³  ë…¸ë ¥í–ˆë‹¤.
- í™•ì‹¤íˆ êµ¬í˜„ì€ ìì£¼í’€ì–´ë´ì•¼ê² ë‹¤. ìµìˆ™í•˜ì§€ ì•Šì€ ë°±íŠ¸ë˜í‚¹ì„ êµ¬í˜„í•˜ë ¤ë‹¤ë³´ë‹ˆ, ê°„ë‹¨í•œ ë°©ì‹ë„ ì½”ë“œë¡œ ì˜ ë‚˜ì˜¤ì§€ì•Šì•˜ë‹¤.(ì¸í…”ë¦¬ì œì´ ë„ì›€ ë§ì´ë°›ìŒ) 
- ê·¸ë¦¬ê³ , í•œ ë©”ì„œë“œì˜ ì—­í• ì„ ìµœëŒ€í•œ ì¤„ì´ë©´ì„œ ê°€ë…ì„±ì„ ë†’ì´ê³ ì í•˜ì˜€ë‹¤. ì•„ì§ ì–´ë–¤ë°©ì‹ì´ ì¢‹ì€ì§€ ì•Šì¢‹ì€ì§€ëŠ” ëª¨ë¥´ê² ì§€ë§Œ, 
  ì ì–´ë„ ë‚´ê°€ ì˜¤ëœë§Œì— ë‹¤ì‹œ ë´¤ì„ë•Œ ì•Œì•„ë³¼ ìˆ˜ ìˆê²Œ ë§Œë“¤ê³ ì ë…¸ë ¥í•œë‹¤.

<img src="https://user-images.githubusercontent.com/104331549/180639292-8c3c3b85-691b-4077-bb23-d0972909429d.png">